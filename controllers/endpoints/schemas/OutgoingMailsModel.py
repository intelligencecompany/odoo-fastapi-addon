
from pydantic import BaseModel, Field
from typing import Optional, List, Any

class OutgoingMailsModel(BaseModel):
    id: Optional[int] = Field(None, alias="id", title="ID", description="")
    message_type: Any = Field(None, alias="message_type", title="Type", description="Used to categorize message generator\n'email': generated by an incoming email e.g. mailgateway\n'comment': generated by user input e.g. through discuss or composer\n'email_outgoing': generated by a mailing\n'notification': generated by system e.g. tracking messages\n'auto_comment': generated by automated notification mechanism e.g. acknowledgment\n'user_notification': generated for a specific recipient")
    mail_message_id: int = Field(0, alias="mail_message_id", title="Message", description="")
    fetchmail_server_id: Optional[int] = Field(None, alias="fetchmail_server_id", title="Inbound Mail Server", description="")
    parent_id: Optional[int] = Field(None, alias="parent_id", title="Parent Message", description="")
    res_id: Optional[Any] = Field(None, alias="res_id", title="Related Document ID", description="")
    record_alias_domain_id: Optional[int] = Field(None, alias="record_alias_domain_id", title="Alias Domain", description="")
    record_company_id: Optional[int] = Field(None, alias="record_company_id", title="Company", description="")
    subtype_id: Optional[int] = Field(None, alias="subtype_id", title="Subtype", description="")
    mail_activity_type_id: Optional[int] = Field(None, alias="mail_activity_type_id", title="Mail Activity Type", description="")
    author_id: Optional[int] = Field(None, alias="author_id", title="Author", description="Author of the message. If not set, email_from may hold an email address that did not match any partner.")
    author_guest_id: Optional[int] = Field(None, alias="author_guest_id", title="Guest", description="")
    message_id: Optional[str] = Field(None, alias="message_id", title="Message-Id", description="Message unique identifier")
    mail_server_id: Optional[int] = Field(None, alias="mail_server_id", title="Outgoing mail server", description="")
    unrestricted_attachment_ids: Optional[List[int]] = Field(None, alias="unrestricted_attachment_ids", title="Unrestricted Attachments", description="")
    recipient_ids: Optional[List[int]] = Field(None, alias="recipient_ids", title="To (Partners)", description="")
    link_preview_ids: Optional[List[int]] = Field(None, alias="link_preview_ids", title="Link Previews", description="")
    reaction_ids: Optional[List[int]] = Field(None, alias="reaction_ids", title="Reactions", description="")
    attachment_ids: Optional[List[int]] = Field(None, alias="attachment_ids", title="Attachments", description="")
    child_ids: Optional[List[int]] = Field(None, alias="child_ids", title="Child Messages", description="")
    partner_ids: Optional[List[int]] = Field(None, alias="partner_ids", title="Recipients", description="")
    notified_partner_ids: Optional[List[int]] = Field(None, alias="notified_partner_ids", title="Partners with Need Action", description="")
    notification_ids: Optional[List[int]] = Field(None, alias="notification_ids", title="Notifications", description="")
    starred_partner_ids: Optional[List[int]] = Field(None, alias="starred_partner_ids", title="Favorited By", description="")
    tracking_value_ids: Optional[List[int]] = Field(None, alias="tracking_value_ids", title="Tracking values", description="Tracked values are stored in a separate model. This field allow to reconstruct the tracking and to generate statistics on the model.")
    mail_ids: Optional[List[int]] = Field(None, alias="mail_ids", title="Mails", description="")
    rating_ids: Optional[List[int]] = Field(None, alias="rating_ids", title="Related ratings", description="")
    letter_ids: Optional[List[int]] = Field(None, alias="letter_ids", title="Letter", description="")
    mail_message_id_int: Optional[int] = Field(None, alias="mail_message_id_int", title="Mail Message Id Int", description="")
    body_html: Optional[Any] = Field(None, alias="body_html", title="Text Contents", description="Rich-text/HTML message")
    body_content: Optional[Any] = Field(None, alias="body_content", title="Rich-text Contents", description="")
    references: Optional[Any] = Field(None, alias="references", title="References", description="Message references, such as identifiers of previous messages")
    headers: Optional[Any] = Field(None, alias="headers", title="Headers", description="")
    restricted_attachment_count: Optional[int] = Field(None, alias="restricted_attachment_count", title="Restricted attachments", description="")
    is_notification: Optional[bool] = Field(None, alias="is_notification", title="Notification Email", description="Mail has been created to notify people of an existing mail.message")
    email_to: Optional[Any] = Field(None, alias="email_to", title="To", description="Message recipients (emails)")
    email_cc: Optional[str] = Field(None, alias="email_cc", title="Cc", description="Carbon copy message recipients")
    state: Optional[Any] = Field(None, alias="state", title="Status", description="")
    failure_type: Optional[Any] = Field(None, alias="failure_type", title="Failure type", description="")
    failure_reason: Optional[Any] = Field(None, alias="failure_reason", title="Failure Reason", description="Failure reason. This is usually the exception thrown by the email server, stored to ease the debugging of mailing issues.")
    auto_delete: Optional[bool] = Field(None, alias="auto_delete", title="Auto Delete", description="This option permanently removes any track of email after it's been sent, including from the Technical menu in the Settings, in order to preserve storage space of your Odoo database.")
    scheduled_date: Optional[str] = Field(None, alias="scheduled_date", title="Scheduled Send Date", description="If set, the queue manager will send the email after the date. If not set, the email will be send as soon as possible. Unless a timezone is specified, it is considered as being in UTC timezone.")
    display_name: Optional[str] = Field(None, alias="display_name", title="Display Name", description="")
    create_uid: Optional[int] = Field(None, alias="create_uid", title="Created by", description="")
    create_date: Optional[str] = Field(None, alias="create_date", title="Created on", description="")
    write_uid: Optional[int] = Field(None, alias="write_uid", title="Last Updated by", description="")
    write_date: Optional[str] = Field(None, alias="write_date", title="Last Updated on", description="")
    subject: Optional[str] = Field(None, alias="subject", title="Subject", description="")
    date: Optional[str] = Field(None, alias="date", title="Date", description="")
    body: Optional[Any] = Field(None, alias="body", title="Contents", description="")
    description: Optional[str] = Field(None, alias="description", title="Short description", description="Message description: either the subject, or the beginning of the body")
    preview: Optional[str] = Field(None, alias="preview", title="Preview", description="The text-only beginning of the body used as email preview.")
    model: Optional[str] = Field(None, alias="model", title="Related Document Model", description="")
    record_name: Optional[str] = Field(None, alias="record_name", title="Message Record Name", description="")
    is_internal: Optional[bool] = Field(None, alias="is_internal", title="Employee Only", description="Hide to public / portal users, independently from subtype configuration.")
    email_from: Optional[str] = Field(None, alias="email_from", title="From", description="Email address of the sender. This field is set when no matching partner is found and replaces the author_id field in the chatter.")
    author_avatar: Optional[Any] = Field(None, alias="author_avatar", title="Author's avatar", description="")
    is_current_user_or_guest_author: Optional[bool] = Field(None, alias="is_current_user_or_guest_author", title="Is Current User Or Guest Author", description="")
    needaction: Optional[bool] = Field(None, alias="needaction", title="Need Action", description="")
    has_error: Optional[bool] = Field(None, alias="has_error", title="Has error", description="")
    pinned_at: Optional[str] = Field(None, alias="pinned_at", title="Pinned", description="Datetime at which the message has been pinned")
    starred: Optional[bool] = Field(None, alias="starred", title="Starred", description="Current user has a starred notification linked to this message")
    reply_to_force_new: Optional[bool] = Field(None, alias="reply_to_force_new", title="No threading for answers", description="If true, answers do not go in the original document discussion thread. Instead, it will check for the reply_to in tracking message-id and redirected accordingly. This has an impact on the generated message-id.")
    reply_to: Optional[str] = Field(None, alias="reply_to", title="Reply-To", description="Reply email address. Setting the reply_to bypasses the automatic thread creation.")
    email_layout_xmlid: Optional[str] = Field(None, alias="email_layout_xmlid", title="Layout", description="")
    email_add_signature: Optional[bool] = Field(None, alias="email_add_signature", title="Email Add Signature", description="")
    rating_value: Optional[Any] = Field(None, alias="rating_value", title="Rating Value", description="")
    has_sms_error: Optional[bool] = Field(None, alias="has_sms_error", title="Has SMS error", description="")
    snailmail_error: Optional[bool] = Field(None, alias="snailmail_error", title="Snailmail message in error", description="")
    parent_author_name: Optional[str] = Field(None, alias="parent_author_name", title="Parent Author Name", description="")
    parent_body: Optional[Any] = Field(None, alias="parent_body", title="Parent Body", description="")

    class ConfigDict:
        from_attributes = True

    @classmethod
    def from_execute_kw(cls, item:dict) -> 'OutgoingMailsModel':
        filtered_item = {}
        schema = OutgoingMailsModel.model_json_schema()

        for key in item.keys():
            value = item[key]
            model_type = 'any'

            if 'anyOf' in schema['properties'][key] and 'type' in schema['properties'][key]['anyOf'][0]:
                model_type = schema['properties'][key]['anyOf'][0]['type']
            elif 'type' in schema['properties'][key]:
                model_type = schema['properties'][key]['type']

            if isinstance(value, list) and model_type != 'array':
                value = value[0] if item[key] else None
            
            if isinstance(value, bool) and model_type == 'string':
                value = ''

            if value is not None:
                filtered_item[key] = value

        return cls(**filtered_item).model_dump(by_alias=True)

    @classmethod
    def list_from_execute_kw(cls, data:List[dict], fields:List[str] = []) -> List['OutgoingMailsModel']:
        transformed = []
        schema = OutgoingMailsModel.model_json_schema()
        
        for item in data:
            filtered_item = {}

            if len(fields) == 0:
                fields = item.keys()

            for key in fields:
                if key in item:
                    value = item[key]
                    model_type = 'any'

                    if 'anyOf' in schema['properties'][key] and 'type' in schema['properties'][key]['anyOf'][0]:
                        model_type = schema['properties'][key]['anyOf'][0]['type']
                    elif 'type' in schema['properties'][key]:
                        model_type = schema['properties'][key]['type']

                    if isinstance(value, list) and model_type != 'array':
                        value = value[0] if item[key] else None
                    
                    if isinstance(value, bool) and model_type == 'string':
                        value = ''

                    if value is not None:
                        filtered_item[key] = value

            transformed.append(cls(**filtered_item).model_dump(by_alias=True))
        return transformed
